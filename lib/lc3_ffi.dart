// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// FFI bindings for LC3 codec
class Lc3Bindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Lc3Bindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Lc3Bindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Return the number of PCM samples in a frame
  /// hrmode          Enable High-Resolution mode (48000 and 96000 sample rates)
  /// dt_us           Frame duration in us, 2500, 5000, 7500 or 10000
  /// sr_hz           Sample rate in Hz, 8000, 16000, 24000, 32000, 48000 or 96000
  /// return          Number of PCM samples, -1 on bad parameters
  int lc3_hr_frame_samples(
    bool hrmode,
    int dt_us,
    int sr_hz,
  ) {
    return _lc3_hr_frame_samples(
      hrmode,
      dt_us,
      sr_hz,
    );
  }

  late final _lc3_hr_frame_samplesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Bool, ffi.Int, ffi.Int)>>(
          'lc3_hr_frame_samples');
  late final _lc3_hr_frame_samples =
      _lc3_hr_frame_samplesPtr.asFunction<int Function(bool, int, int)>();

  int lc3_frame_samples(
    int dt_us,
    int sr_hz,
  ) {
    return _lc3_frame_samples(
      dt_us,
      sr_hz,
    );
  }

  late final _lc3_frame_samplesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'lc3_frame_samples');
  late final _lc3_frame_samples =
      _lc3_frame_samplesPtr.asFunction<int Function(int, int)>();

  /// Return the size of frames, from bitrate
  /// hrmode          Enable High-Resolution mode (48000 and 96000 sample rates)
  /// dt_us           Frame duration in us, 2500, 5000, 7500 or 10000
  /// sr_hz           Sample rate in Hz, 8000, 16000, 24000, 32000, 48000 or 96000
  /// bitrate         Target bitrate in bit per second, 0 or `INT_MAX` returns
  /// respectively the minimum and maximum allowed size.
  /// return          The floor size in bytes of the frames, -1 on bad parameters
  int lc3_hr_frame_bytes(
    bool hrmode,
    int dt_us,
    int sr_hz,
    int bitrate,
  ) {
    return _lc3_hr_frame_bytes(
      hrmode,
      dt_us,
      sr_hz,
      bitrate,
    );
  }

  late final _lc3_hr_frame_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Bool, ffi.Int, ffi.Int, ffi.Int)>>('lc3_hr_frame_bytes');
  late final _lc3_hr_frame_bytes =
      _lc3_hr_frame_bytesPtr.asFunction<int Function(bool, int, int, int)>();

  int lc3_frame_bytes(
    int dt_us,
    int bitrate,
  ) {
    return _lc3_frame_bytes(
      dt_us,
      bitrate,
    );
  }

  late final _lc3_frame_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'lc3_frame_bytes');
  late final _lc3_frame_bytes =
      _lc3_frame_bytesPtr.asFunction<int Function(int, int)>();

  /// Return the size of frame blocks, from bitrate
  /// A frame block contains the frame data from all channels.
  /// hrmode          Enable High-Resolution mode (48000 and 96000 sample rates)
  /// dt_us           Frame duration in us, 2500, 5000, 7500 or 10000
  /// sr_hz           Sample rate in Hz, 8000, 16000, 24000, 32000, 48000 or 96000
  /// nchannels       The number of channels (or frames) in the block (<= 8)
  /// bitrate         Target bitrate in bit per second, 0 or `INT_MAX` returns
  /// respectively the minimum and maximum allowed size.
  /// return          The floor size in bytes of the frames, -1 on bad parameters
  int lc3_hr_frame_block_bytes(
    bool hrmode,
    int dt_us,
    int sr_hz,
    int nchannels,
    int bitrate,
  ) {
    return _lc3_hr_frame_block_bytes(
      hrmode,
      dt_us,
      sr_hz,
      nchannels,
      bitrate,
    );
  }

  late final _lc3_hr_frame_block_bytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Bool, ffi.Int, ffi.Int, ffi.Int,
              ffi.Int)>>('lc3_hr_frame_block_bytes');
  late final _lc3_hr_frame_block_bytes = _lc3_hr_frame_block_bytesPtr
      .asFunction<int Function(bool, int, int, int, int)>();

  int lc3_frame_block_bytes(
    int dt_us,
    int nframes,
    int bitrate,
  ) {
    return _lc3_frame_block_bytes(
      dt_us,
      nframes,
      bitrate,
    );
  }

  late final _lc3_frame_block_bytesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'lc3_frame_block_bytes');
  late final _lc3_frame_block_bytes =
      _lc3_frame_block_bytesPtr.asFunction<int Function(int, int, int)>();

  /// Resolve the bitrate, from the size of frames
  /// hrmode          Enable High-Resolution mode (48000 and 96000 sample rates)
  /// dt_us           Frame duration in us, 2500, 5000, 7500 or 10000
  /// sr_hz           Sample rate in Hz, 8000, 16000, 24000, 32000, 48000 or 96000
  /// nbytes          Size in bytes of the frames or frame blocks
  /// return          The ceiled bitrate in bps, -1 on bad parameters
  int lc3_hr_resolve_bitrate(
    bool hrmode,
    int dt_us,
    int sr_hz,
    int nbytes,
  ) {
    return _lc3_hr_resolve_bitrate(
      hrmode,
      dt_us,
      sr_hz,
      nbytes,
    );
  }

  late final _lc3_hr_resolve_bitratePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Bool, ffi.Int, ffi.Int, ffi.Int)>>('lc3_hr_resolve_bitrate');
  late final _lc3_hr_resolve_bitrate = _lc3_hr_resolve_bitratePtr
      .asFunction<int Function(bool, int, int, int)>();

  int lc3_resolve_bitrate(
    int dt_us,
    int nbytes,
  ) {
    return _lc3_resolve_bitrate(
      dt_us,
      nbytes,
    );
  }

  late final _lc3_resolve_bitratePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'lc3_resolve_bitrate');
  late final _lc3_resolve_bitrate =
      _lc3_resolve_bitratePtr.asFunction<int Function(int, int)>();

  /// Return algorithmic delay, as a number of samples
  /// hrmode          Enable High-Resolution mode (48000 and 96000 sample rates)
  /// dt_us           Frame duration in us, 2500, 5000, 7500 or 10000
  /// sr_hz           Sample rate in Hz, 8000, 16000, 24000, 32000, 48000 or 96000
  /// return          Number of algorithmic delay samples, -1 on bad parameters
  int lc3_hr_delay_samples(
    bool hrmode,
    int dt_us,
    int sr_hz,
  ) {
    return _lc3_hr_delay_samples(
      hrmode,
      dt_us,
      sr_hz,
    );
  }

  late final _lc3_hr_delay_samplesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Bool, ffi.Int, ffi.Int)>>(
          'lc3_hr_delay_samples');
  late final _lc3_hr_delay_samples =
      _lc3_hr_delay_samplesPtr.asFunction<int Function(bool, int, int)>();

  int lc3_delay_samples(
    int dt_us,
    int sr_hz,
  ) {
    return _lc3_delay_samples(
      dt_us,
      sr_hz,
    );
  }

  late final _lc3_delay_samplesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'lc3_delay_samples');
  late final _lc3_delay_samples =
      _lc3_delay_samplesPtr.asFunction<int Function(int, int)>();

  /// Return size needed for an encoder
  /// hrmode          Enable High-Resolution mode (48000 and 96000 sample rates)
  /// dt_us           Frame duration in us, 2500, 5000, 7500 or 10000
  /// sr_hz           Sample rate in Hz, 8000, 16000, 24000, 32000, 48000 or 96000
  /// return          Size of then encoder in bytes, 0 on bad parameters
  ///
  /// The `sr_hz` parameter is the sample rate of the PCM input stream,
  /// and will match `sr_pcm_hz` of `lc3_hr_setup_encoder()`.
  int lc3_hr_encoder_size(
    bool hrmode,
    int dt_us,
    int sr_hz,
  ) {
    return _lc3_hr_encoder_size(
      hrmode,
      dt_us,
      sr_hz,
    );
  }

  late final _lc3_hr_encoder_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Bool, ffi.Int, ffi.Int)>>('lc3_hr_encoder_size');
  late final _lc3_hr_encoder_size =
      _lc3_hr_encoder_sizePtr.asFunction<int Function(bool, int, int)>();

  int lc3_encoder_size(
    int dt_us,
    int sr_hz,
  ) {
    return _lc3_encoder_size(
      dt_us,
      sr_hz,
    );
  }

  late final _lc3_encoder_sizePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Int, ffi.Int)>>(
          'lc3_encoder_size');
  late final _lc3_encoder_size =
      _lc3_encoder_sizePtr.asFunction<int Function(int, int)>();

  /// Setup encoder
  /// hrmode          Enable High-Resolution mode (48000 and 96000 sample rates)
  /// dt_us           Frame duration in us, 2500, 5000, 7500 or 10000
  /// sr_hz           Sample rate in Hz, 8000, 16000, 24000, 32000, 48000 or 96000
  /// sr_pcm_hz       Input sample rate, downsampling option of input, or 0
  /// mem             Encoder memory space, aligned to pointer type
  /// return          Encoder as an handle, NULL on bad parameters
  ///
  /// The `sr_pcm_hz` parameter is a downsampling option of PCM input,
  /// the value `0` fallback to the sample rate of the encoded stream `sr_hz`.
  /// When used, `sr_pcm_hz` is intended to be higher or equal to the encoder
  /// sample rate `sr_hz`. The size of the context needed, given by
  /// `lc3_hr_encoder_size()` will be set accordingly to `sr_pcm_hz`.
  lc3_encoder_t lc3_hr_setup_encoder(
    bool hrmode,
    int dt_us,
    int sr_hz,
    int sr_pcm_hz,
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _lc3_hr_setup_encoder(
      hrmode,
      dt_us,
      sr_hz,
      sr_pcm_hz,
      mem,
    );
  }

  late final _lc3_hr_setup_encoderPtr = _lookup<
      ffi.NativeFunction<
          lc3_encoder_t Function(ffi.Bool, ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Void>)>>('lc3_hr_setup_encoder');
  late final _lc3_hr_setup_encoder = _lc3_hr_setup_encoderPtr.asFunction<
      lc3_encoder_t Function(bool, int, int, int, ffi.Pointer<ffi.Void>)>();

  lc3_encoder_t lc3_setup_encoder(
    int dt_us,
    int sr_hz,
    int sr_pcm_hz,
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _lc3_setup_encoder(
      dt_us,
      sr_hz,
      sr_pcm_hz,
      mem,
    );
  }

  late final _lc3_setup_encoderPtr = _lookup<
      ffi.NativeFunction<
          lc3_encoder_t Function(ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Void>)>>('lc3_setup_encoder');
  late final _lc3_setup_encoder = _lc3_setup_encoderPtr.asFunction<
      lc3_encoder_t Function(int, int, int, ffi.Pointer<ffi.Void>)>();

  /// Disable LTPF analysis
  /// encoder        Handle of the encoder
  ///
  /// LTPF analysis is known to take a lot of CPU time and work quite bad on
  /// synthetic signals such as sine waves, so it might be beneficial to
  /// disable it in such cases.
  void lc3_encoder_disable_ltpf(
    lc3_encoder_t encoder,
  ) {
    return _lc3_encoder_disable_ltpf(
      encoder,
    );
  }

  late final _lc3_encoder_disable_ltpfPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lc3_encoder_t)>>(
          'lc3_encoder_disable_ltpf');
  late final _lc3_encoder_disable_ltpf =
      _lc3_encoder_disable_ltpfPtr.asFunction<void Function(lc3_encoder_t)>();

  /// Encode a frame
  /// encoder         Handle of the encoder
  /// fmt             PCM input format
  /// pcm, stride     Input PCM samples, and count between two consecutives
  /// nbytes          Target size, in bytes, of the frame
  /// out             Output buffer of `nbytes` size
  /// return          0: On success  -1: Wrong parameters
  int lc3_encode(
    lc3_encoder_t encoder,
    lc3_pcm_format fmt,
    ffi.Pointer<ffi.Void> pcm,
    int stride,
    int nbytes,
    ffi.Pointer<ffi.Void> out,
  ) {
    return _lc3_encode(
      encoder,
      fmt.value,
      pcm,
      stride,
      nbytes,
      out,
    );
  }

  late final _lc3_encodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              lc3_encoder_t,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Void>)>>('lc3_encode');
  late final _lc3_encode = _lc3_encodePtr.asFunction<
      int Function(lc3_encoder_t, int, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>)>();

  /// Return size needed for an decoder
  /// hrmode          Enable High-Resolution mode (48000 and 96000 sample rates)
  /// dt_us           Frame duration in us, 2500, 5000, 7500 or 10000
  /// sr_hz           Sample rate in Hz, 8000, 16000, 24000, 32000, 48000 or 96000
  /// return          Size of then decoder in bytes, 0 on bad parameters
  ///
  /// The `sr_hz` parameter is the sample rate of the PCM output stream,
  /// and will match `sr_pcm_hz` of `lc3_hr_setup_decoder()`.
  int lc3_hr_decoder_size(
    bool hrmode,
    int dt_us,
    int sr_hz,
  ) {
    return _lc3_hr_decoder_size(
      hrmode,
      dt_us,
      sr_hz,
    );
  }

  late final _lc3_hr_decoder_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Bool, ffi.Int, ffi.Int)>>('lc3_hr_decoder_size');
  late final _lc3_hr_decoder_size =
      _lc3_hr_decoder_sizePtr.asFunction<int Function(bool, int, int)>();

  int lc3_decoder_size(
    int dt_us,
    int sr_hz,
  ) {
    return _lc3_decoder_size(
      dt_us,
      sr_hz,
    );
  }

  late final _lc3_decoder_sizePtr =
      _lookup<ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Int, ffi.Int)>>(
          'lc3_decoder_size');
  late final _lc3_decoder_size =
      _lc3_decoder_sizePtr.asFunction<int Function(int, int)>();

  /// Setup decoder
  /// hrmode          Enable High-Resolution mode (48000 and 96000 sample rates)
  /// dt_us           Frame duration in us, 2500, 5000, 7500 or 10000
  /// sr_hz           Sample rate in Hz, 8000, 16000, 24000, 32000, 48000 or 96000
  /// sr_pcm_hz       Output sample rate, upsampling option of output (or 0)
  /// mem             Decoder memory space, aligned to pointer type
  /// return          Decoder as an handle, NULL on bad parameters
  ///
  /// The `sr_pcm_hz` parameter is an upsampling option of PCM output,
  /// the value `0` fallback to the sample rate of the decoded stream `sr_hz`.
  /// When used, `sr_pcm_hz` is intended to be higher or equal to the decoder
  /// sample rate `sr_hz`. The size of the context needed, given by
  /// `lc3_hr_decoder_size()` will be set accordingly to `sr_pcm_hz`.
  lc3_decoder_t lc3_hr_setup_decoder(
    bool hrmode,
    int dt_us,
    int sr_hz,
    int sr_pcm_hz,
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _lc3_hr_setup_decoder(
      hrmode,
      dt_us,
      sr_hz,
      sr_pcm_hz,
      mem,
    );
  }

  late final _lc3_hr_setup_decoderPtr = _lookup<
      ffi.NativeFunction<
          lc3_decoder_t Function(ffi.Bool, ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Void>)>>('lc3_hr_setup_decoder');
  late final _lc3_hr_setup_decoder = _lc3_hr_setup_decoderPtr.asFunction<
      lc3_decoder_t Function(bool, int, int, int, ffi.Pointer<ffi.Void>)>();

  lc3_decoder_t lc3_setup_decoder(
    int dt_us,
    int sr_hz,
    int sr_pcm_hz,
    ffi.Pointer<ffi.Void> mem,
  ) {
    return _lc3_setup_decoder(
      dt_us,
      sr_hz,
      sr_pcm_hz,
      mem,
    );
  }

  late final _lc3_setup_decoderPtr = _lookup<
      ffi.NativeFunction<
          lc3_decoder_t Function(ffi.Int, ffi.Int, ffi.Int,
              ffi.Pointer<ffi.Void>)>>('lc3_setup_decoder');
  late final _lc3_setup_decoder = _lc3_setup_decoderPtr.asFunction<
      lc3_decoder_t Function(int, int, int, ffi.Pointer<ffi.Void>)>();

  /// Decode a frame
  /// decoder         Handle of the decoder
  /// in, nbytes      Input bitstream, and size in bytes, NULL performs PLC
  /// fmt             PCM output format
  /// pcm, stride     Output PCM samples, and count between two consecutives
  /// return          0: On success  1: PLC operated  -1: Wrong parameters
  int lc3_decode(
    lc3_decoder_t decoder,
    ffi.Pointer<ffi.Void> in$,
    int nbytes,
    lc3_pcm_format fmt,
    ffi.Pointer<ffi.Void> pcm,
    int stride,
  ) {
    return _lc3_decode(
      decoder,
      in$,
      nbytes,
      fmt.value,
      pcm,
      stride,
    );
  }

  late final _lc3_decodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(lc3_decoder_t, ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.UnsignedInt, ffi.Pointer<ffi.Void>, ffi.Int)>>('lc3_decode');
  late final _lc3_decode = _lc3_decodePtr.asFunction<
      int Function(lc3_decoder_t, ffi.Pointer<ffi.Void>, int, int,
          ffi.Pointer<ffi.Void>, int)>();
}

/// Frame duration
enum lc3_dt {
  LC3_DT_2M5(0),
  LC3_DT_5M(1),
  LC3_DT_7M5(2),
  LC3_DT_10M(3),
  LC3_NUM_DT(4);

  final int value;
  const lc3_dt(this.value);

  static lc3_dt fromValue(int value) => switch (value) {
        0 => LC3_DT_2M5,
        1 => LC3_DT_5M,
        2 => LC3_DT_7M5,
        3 => LC3_DT_10M,
        4 => LC3_NUM_DT,
        _ => throw ArgumentError('Unknown value for lc3_dt: $value'),
      };
}

/// Sampling frequency and high-resolution mode
enum lc3_srate {
  LC3_SRATE_8K(0),
  LC3_SRATE_16K(1),
  LC3_SRATE_24K(2),
  LC3_SRATE_32K(3),
  LC3_SRATE_48K(4),
  LC3_SRATE_48K_HR(5),
  LC3_SRATE_96K_HR(6),
  LC3_NUM_SRATE(7);

  final int value;
  const lc3_srate(this.value);

  static lc3_srate fromValue(int value) => switch (value) {
        0 => LC3_SRATE_8K,
        1 => LC3_SRATE_16K,
        2 => LC3_SRATE_24K,
        3 => LC3_SRATE_32K,
        4 => LC3_SRATE_48K,
        5 => LC3_SRATE_48K_HR,
        6 => LC3_SRATE_96K_HR,
        7 => LC3_NUM_SRATE,
        _ => throw ArgumentError('Unknown value for lc3_srate: $value'),
      };
}

/// Encoder state and memory
final class lc3_attdet_analysis extends ffi.Struct {
  @ffi.Int32()
  external int en1;

  @ffi.Int32()
  external int an1;

  @ffi.Int()
  external int p_att;
}

/// Encoder state and memory
typedef lc3_attdet_analysis_t = lc3_attdet_analysis;

final class lc3_ltpf_hp50_state extends ffi.Struct {
  @ffi.Int64()
  external int s1;

  @ffi.Int64()
  external int s2;
}

final class lc3_ltpf_analysis extends ffi.Struct {
  @ffi.Bool()
  external bool active;

  @ffi.Int()
  external int pitch;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Float> nc;

  external lc3_ltpf_hp50_state hp50;

  @ffi.Array.multi([384])
  external ffi.Array<ffi.Int16> x_12k8;

  @ffi.Array.multi([178])
  external ffi.Array<ffi.Int16> x_6k4;

  @ffi.Int()
  external int tc;
}

typedef lc3_ltpf_analysis_t = lc3_ltpf_analysis;

final class lc3_spec_analysis extends ffi.Struct {
  @ffi.Float()
  external double nbits_off;

  @ffi.Int()
  external int nbits_spare;
}

typedef lc3_spec_analysis_t = lc3_spec_analysis;

final class lc3_encoder extends ffi.Struct {
  @ffi.Bool()
  external bool ltpf_bypass;

  @ffi.UnsignedInt()
  external int dtAsInt;

  lc3_dt get dt => lc3_dt.fromValue(dtAsInt);

  @ffi.UnsignedInt()
  external int srAsInt;

  lc3_srate get sr => lc3_srate.fromValue(srAsInt);

  @ffi.UnsignedInt()
  external int sr_pcmAsInt;

  lc3_srate get sr_pcm => lc3_srate.fromValue(sr_pcmAsInt);

  external lc3_attdet_analysis_t attdet;

  external lc3_ltpf_analysis_t ltpf;

  external lc3_spec_analysis_t spec;

  @ffi.Int()
  external int xt_off;

  @ffi.Int()
  external int xs_off;

  @ffi.Int()
  external int xd_off;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Float> x;
}

/// Decoder state and memory
final class lc3_ltpf_synthesis extends ffi.Struct {
  @ffi.Bool()
  external bool active;

  @ffi.Int()
  external int pitch;

  @ffi.Array.multi([24])
  external ffi.Array<ffi.Float> c;

  @ffi.Array.multi([12])
  external ffi.Array<ffi.Float> x;
}

/// Decoder state and memory
typedef lc3_ltpf_synthesis_t = lc3_ltpf_synthesis;

final class lc3_plc_state extends ffi.Struct {
  @ffi.Uint16()
  external int seed;

  @ffi.Int()
  external int count;

  @ffi.Float()
  external double alpha;
}

typedef lc3_plc_state_t = lc3_plc_state;

final class lc3_decoder extends ffi.Struct {
  @ffi.UnsignedInt()
  external int dtAsInt;

  lc3_dt get dt => lc3_dt.fromValue(dtAsInt);

  @ffi.UnsignedInt()
  external int srAsInt;

  lc3_srate get sr => lc3_srate.fromValue(srAsInt);

  @ffi.UnsignedInt()
  external int sr_pcmAsInt;

  lc3_srate get sr_pcm => lc3_srate.fromValue(sr_pcmAsInt);

  external lc3_ltpf_synthesis_t ltpf;

  external lc3_plc_state_t plc;

  @ffi.Int()
  external int xh_off;

  @ffi.Int()
  external int xs_off;

  @ffi.Int()
  external int xd_off;

  @ffi.Int()
  external int xg_off;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Float> x;
}

/// PCM Sample Format
/// S16      Signed 16 bits, in 16 bits words (int16_t)
/// S24      Signed 24 bits, using low three bytes of 32 bits words (int32_t).
/// The high byte sign extends (bits 31..24 set to b23).
/// S24_3LE  Signed 24 bits packed in 3 bytes little endian
/// FLOAT    Floating point 32 bits (float type), in range -1 to 1
enum lc3_pcm_format {
  LC3_PCM_FORMAT_S16(0),
  LC3_PCM_FORMAT_S24(1),
  LC3_PCM_FORMAT_S24_3LE(2),
  LC3_PCM_FORMAT_FLOAT(3);

  final int value;
  const lc3_pcm_format(this.value);

  static lc3_pcm_format fromValue(int value) => switch (value) {
        0 => LC3_PCM_FORMAT_S16,
        1 => LC3_PCM_FORMAT_S24,
        2 => LC3_PCM_FORMAT_S24_3LE,
        3 => LC3_PCM_FORMAT_FLOAT,
        _ => throw ArgumentError('Unknown value for lc3_pcm_format: $value'),
      };
}

/// Handle
typedef lc3_encoder_t = ffi.Pointer<lc3_encoder>;
typedef lc3_decoder_t = ffi.Pointer<lc3_decoder>;

/// Static memory of encoder/decoder contexts
///
/// Propose types suitable for static memory allocation, supporting
/// any frame duration, and maximum sample rates 16k and 48k respectively
/// You can customize your type using the `LC3_ENCODER_MEM_T` or
/// `LC3_DECODER_MEM_T` macro.
final class lc3_encoder_mem_16k_t extends ffi.Struct {
  external lc3_encoder __e;

  @ffi.Array.multi([349])
  external ffi.Array<ffi.Float> __x;
}

final class lc3_encoder_mem_48k_t extends ffi.Struct {
  external lc3_encoder __e;

  @ffi.Array.multi([1049])
  external ffi.Array<ffi.Float> __x;
}

final class lc3_decoder_mem_16k_t extends ffi.Struct {
  external lc3_decoder __d;

  @ffi.Array.multi([739])
  external ffi.Array<ffi.Float> __x;
}

final class lc3_decoder_mem_48k_t extends ffi.Struct {
  external lc3_decoder __d;

  @ffi.Array.multi([2219])
  external ffi.Array<ffi.Float> __x;
}

const int LC3_MIN_BITRATE = 16000;

const int LC3_MAX_BITRATE = 320000;

const int LC3_HR_MAX_BITRATE = 672000;

const int LC3_MIN_FRAME_BYTES = 20;

const int LC3_MAX_FRAME_BYTES = 400;

const int LC3_HR_MAX_FRAME_BYTES = 625;

const int LC3_MIN_FRAME_SAMPLES = 20;

const int LC3_MAX_FRAME_SAMPLES = 480;

const int LC3_HR_MAX_FRAME_SAMPLES = 960;
